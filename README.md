# Programmers.2018_KAKAOBLINDRECRUITMENT_Java_MuckbangLive

## 프로그래머스 2018 카카오 블라인드 리쿠르트 > 무지의 먹방 라이브

### 1. 문제설명
문제: https://programmers.co.kr/learn/courses/30/lessons/42891

input으로 음식을 먹는데 걸리는 시간(초)들의 배열 int[] food_times, 네트워크 장애가 발생할 시간 k초가 들어온다. 매 음식들을 번갈아 가면서 1초당 먹을 때 k초때 방송이 멈춘후 다시 켜졌을 때 먹을 음식의 번호를 return하는 문제. 다먹은 음식이 있다면 아직 남아있는 다음 음식을 먹기 시작한다.

ex) food_times = [3, 1, 2], k = 5

먹는 순서 1 2 3 1 3 -> 다음번 1

> 효율성 테스트에 부분점수가 있는 문제

### 2. 풀이
문제를 해결하기 위한 두가지 방법이있다.

1. 모든 food_times를 순서대로 탐색하며 food_times[i]--를 해주며 k번째 index를 계산하는 방법.

간단하지만 이 방법은 효율성 테스트에서 실패한다.

2. 가장 적은 시간이 걸리는 음식양만큼 food_times에서 빼주면서 계산하는 방법.

k만큼의 index를 탐색하지 않아도 되며 최대 걸리는 시간은 food_times.length만큼 걸린다.

Food class를 만들고 먹는데 걸리는 시간에 대해 오름차순으로 정렬한다.

(첫번째 음식을 모두 먹는데 걸리는 시간) * (남은 음식의 개수)가 k보다 작다면 한번에 (첫번째 음식을 모두 먹는데 걸리는 시간) * (남은 음식의 개수)만큼의 index를 탐색한 효과를 얻을 수있 다.

(첫번째 음식을 모두 먹는데 걸리는 시간) * (남은 음식의 개수)가 k보다 크다면 남은 음식에 대해 음식 순서에 따라 정렬후 k번째 음식을 return하여 해결한다.

### 3. 어려웠던 점

효율성 테스트를 위해서 저런 아이디어는 정말 순간에 떠오르지가 않는다. 손으로 input들을 그려보며 사용할 수 있는 정렬들을 적용해보며 가장 효율적인 방법을 찾는 연습을 해야겠다.
